// Copyright 2019 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.cloud.broker.hadoop.fs;

import com.google.api.client.http.GenericUrl;
import com.google.common.io.BaseEncoding;
import org.ietf.jgss.GSSException;

import io.grpc.ManagedChannel;
import io.grpc.Metadata;
import io.grpc.stub.MetadataUtils;
import org.apache.hadoop.conf.Configuration;

// Classes dynamically generated by protobuf-maven-plugin:
import com.google.cloud.broker.protobuf.BrokerGrpc;


public final class BrokerGateway {

    protected BrokerGrpc.BrokerBlockingStub stub;
    protected ManagedChannel managedChannel;
    protected Configuration config;
    private String brokerPrincipal;

    public BrokerGateway(Configuration config) {
        this(config,null);
    }

    public BrokerGateway(Configuration config, String sessionToken) {
        this.config = config;

        brokerPrincipal = config.get("gcp.token.broker.principal", "");
        String brokerUri = config.get("gcp.token.broker.uri", "https://localhost:443");
        GenericUrl url = new GenericUrl(brokerUri);
        String brokerHostname = url.getHost();
        int brokerPort = url.getPort();
        boolean tlsEnabled = url.getScheme().equalsIgnoreCase("https");
        String tlsCertificate = config.get("gcp.token.broker.tls.certificate", "");

        managedChannel = GrpcUtils.newManagedChannel(brokerHostname, brokerPort, tlsEnabled, tlsCertificate);
        stub = GrpcUtils.newStub(managedChannel);

        if (sessionToken != null) {
            setDelegationToken(sessionToken);
        }
        else {
            try {
                setSPNEGOToken();
            } catch (GSSException e) {
                // Clean up the channel before re-throwing the exception
                managedChannel.shutdownNow();
                throw new RuntimeException(
                    "User is not logged-in with Kerberos or cannot authenticate with the broker. Kerberos error message: " + e.getMessage());
            }
        }
    }

    public BrokerGrpc.BrokerBlockingStub getStub() {
        return stub;
    }

    public ManagedChannel getManagedChannel() {
        return managedChannel;
    }

    private void setSPNEGOToken() throws GSSException {
        String encodedToken = BaseEncoding.base64().encode(SpnegoUtils.newSPNEGOToken(brokerPrincipal));

        // Set the 'authorization' header with the SPNEGO token
        Metadata metadata = new Metadata();
        Metadata.Key<String> key = Metadata.Key.of("authorization", Metadata.ASCII_STRING_MARSHALLER);
        metadata.put(key, "Negotiate " + encodedToken);
        stub = MetadataUtils.attachHeaders(stub, metadata);
    }

    private void setDelegationToken(String sessionToken) {
        // Set the delegation token in the 'authorization' header
        Metadata metadata = new Metadata();
        Metadata.Key<String> key = Metadata.Key.of("authorization", Metadata.ASCII_STRING_MARSHALLER);
        metadata.put(key, "BrokerSession " + sessionToken);
        stub = MetadataUtils.attachHeaders(stub, metadata);
    }

}